<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-cloud/1.2.5/d3.layout.cloud.min.js"></script>
    <style>
        .container {
            flex-wrap: wrap;
            justify-content: space-around;
        }
        .visualization {
            min-width: 300px;
            margin: 20px;
        }
        .word-cloud text:hover {
            fill: #ff4081;
            cursor: pointer;
        }
        #heatmap .cell:hover,
        #heatmap .cell-value {
            cursor: pointer;
        }
        #heatmap .labelHighlight{
            font-weight: bold;
        }
        .noselect {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }    
    </style>
</head>
<body>
    <h1>Tag Analysis Visualizations</h1>
    <div class="container">
        <div class="visualization">
            <h2>Tag Frequency Chart</h2>
            <div id="chart"></div>
        </div>  
        <div class="visualization">
            <h2>Tag Cloud</h2>
            <div id="cloud"></div>
        </div>
        <div class="visualization">
            <h2>Co-occurence heat map</h2>
            <div id="heatmap"></div>
        </div>        
        <div class="visualization">
            <h2>Pocket entries</h2>
            <div id="list"></div>
        </div>
        
    </div>


    <script>
    function preprocessData(data) {
        return data.map(item => ({
            id: item.id,
            title: item.title,
            tags: item.tags || [],
            time_added: new Date(item.time_added * 1000)
        }));
    }        

    function prepTagData(data) {
        // Process data: count occurrences of each tag
        const tagCounts = {};
        const itemList = [];
        data.forEach(item => {
            if (item.tags) {
                item.tags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
                itemList.push(item);
            }
        });
        return tagCounts;
    }

    function analyzeTagCooccurrence(data) {
        const pairs = [];
        data.forEach(item => {
            if (Array.isArray(item.tags)) {
                const sortedTags = item.tags.sort();
                for (let i = 0; i < sortedTags.length; i++) {
                    for (let j = i + 1; j < sortedTags.length; j++) {
                        pairs.push([sortedTags[i], sortedTags[j]]);
                    }
                }
            }
        });

        const cooccurrenceCounts = pairs.reduce((acc, pair) => {
            const key = pair.join('|');
            acc[key] = (acc[key] || 0) + 1;
            return acc;
        }, {});

        return Object.entries(cooccurrenceCounts).map(([key, count]) => {
            const [tag1, tag2] = key.split('|');
            return { Tag1: tag1, Tag2: tag2, Cooccurrence: count };
        });
    }    

    function generateCooccurrenceMatrix(cooccurrenceData) {
        // Create initial matrix
        const matrix = {};
        cooccurrenceData.forEach(({ Tag1, Tag2, Cooccurrence }) => {
            if (!matrix[Tag1]) matrix[Tag1] = {};
            if (!matrix[Tag2]) matrix[Tag2] = {};
            matrix[Tag1][Tag2] = (matrix[Tag1][Tag2] || 0) + Cooccurrence;
            matrix[Tag2][Tag1] = (matrix[Tag2][Tag1] || 0) + Cooccurrence;
        });
        // Create ordered matrix
        const orderedMatrix = {};
        const sortedTags = Object.keys(matrix).sort();
        
        sortedTags.forEach(tag1 => {
            orderedMatrix[tag1] = {};
            sortedTags.forEach(tag2 => {
                orderedMatrix[tag1][tag2] = matrix[tag1][tag2] || 0;
            });
        });

        return orderedMatrix;
    }    

    function visualizeCooccurrenceMatrix(matrix) {
        const tags = Object.keys(matrix);
        const margin = { top: 80, right: 100, bottom: 100, left: 80 };
        const size = 800;
        const innerSize = size - margin.left - margin.right;
        const cellSize = innerSize / (tags.length + 1);

        const svg = d3.select("#heatmap")
            .append("svg")
            .attr("width", size)
            .attr("height", size);

        // Helper function to create axis tag labels
        function createAxisLabels(svg, tags, cellSize, margin, isXAxis) {
            // stuff for both axis
            const labelGroup = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            const labelsData = [...tags, "Sum"];
            const labels = labelGroup.selectAll(isXAxis ? ".x-label" : ".y-label")
                .data(labelsData)
                .enter().append("text")
                .attr("class", isXAxis ? "x-label" : "y-label")
                .style("font-size", "10px")
                .text(d => d);

            // stuff for x axis
            if (isXAxis) {
                labels
                    .attr("x", (d, i) => (i * cellSize) + cellSize/2)
                    .attr("y", -10)
                    .attr("text-anchor", "start")
                    .attr("transform", (d, i) => {
                        const x = (i * cellSize) + cellSize/2;
                        return `rotate(-45, ${x}, -10)`;
                    });
            
            // stuff for y axis
            } else {
                labels
                    .attr("x", -10)
                    .attr("y", (d, i) => (i * cellSize) + cellSize/2)
                    .attr("text-anchor", "end")
                    .attr("alignment-baseline", "middle");
            }

            return labels;
        }

        // Create x and y axis labels
        const xLabels = createAxisLabels(svg, tags, cellSize, margin, true);
        const yLabels = createAxisLabels(svg, tags, cellSize, margin, false);

        // Calculate row and column sums
        const rowSums = tags.map(tag1 => 
            tags.reduce((sum, tag2) => sum + (matrix[tag1][tag2] || 0), 0)
            );
        const colSums = tags.map(tag2 => 
            tags.reduce((sum, tag1) => sum + (matrix[tag1][tag2] || 0), 0)
        );

        // Create sum color scales
        const sumColorScale = d3.scaleSequential(d3.interpolateOranges)
            .domain([0, Math.max(d3.max(rowSums), d3.max(colSums))]);

        // Create matrix color scales
        const maxValue = d3.max(tags.flatMap(tag1 => 
            tags.map(tag2 => matrix[tag1][tag2] || 0)
        ));
        const cellColorScale = d3.scaleSequential(d3.interpolateGreens)
            .domain([0, maxValue]);
        const highlightColorScale = d3.scaleSequential(d3.interpolateOranges)
            .domain([0, maxValue]); 


        const cellData = [
            // Original matrix data
            ...tags.flatMap((tag1, i) =>
                tags.map((tag2, j) => ({
                    tag1,
                    tag2,
                    value: matrix[tag1][tag2] || 0,
                    x: j,
                    y: i,
                    isSum: false
                }))
            ),
            // Row sums
            ...tags.map((tag, i) => ({
                tag1: tag,
                tag2: 'Sum',
                value: rowSums[i],
                x: tags.length,
                y: i,
                isSum: true
            })),
            // Column sums
            ...tags.map((tag, i) => ({
                tag1: 'Sum',
                tag2: tag,
                value: colSums[i],
                x: i,
                y: tags.length,
                isSum: true
            })),
            // Total sum cell
            {
                tag1: 'Sum',
                tag2: 'Sum',
                value: d3.sum(rowSums),
                x: tags.length,
                y: tags.length,
                isSum: true
            }
        ];

        const heatmapGroup = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Add the 2D array data to the cells
        const cells = heatmapGroup.selectAll(".cell")
            .data(cellData)
            .enter().append("rect")
            .attr("class", "cell")
            .attr("x", d => d.x * cellSize)
            .attr("y", d => d.y * cellSize)
            .attr("width", d => (d.tag2 === 'Sum' && d.tag1 !== 'Sum')  ? Math.max(10, Math.round(Math.log(d.value + 1) * 10)) + 'px' : cellSize)
            .attr("height", d => (d.tag1 === 'Sum' && d.tag2 !== 'Sum') ? Math.max(10, Math.round(Math.log(d.value + 1) * 10)) + 'px' : cellSize)
            .style("fill", d => d.isSum ? sumColorScale(d.value) : cellColorScale(d.value));
        
        // Add the text labels to the cells where necessary
        const texts = heatmapGroup.selectAll(".cell-value")
            .data(cellData)
            .enter().append("text")
            .attr("class", "cell-value")
            .attr("x", d => (d.x + 0.5) * cellSize)
            .attr("y", d => (d.y + 0.5) * cellSize)
            .attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .style("font-size", "10px")
            .style("fill", d => {
                // Ensure text color contrasts with background color
                const backgroundColor = d.isSum ? sumColorScale(d.value) : cellColorScale(d.value);
                const rgb = d3.color(backgroundColor).rgb();
                const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b);
                return luminance > 180 ? "black" : "white";
            })
            .text(d => d.value > 0 ? d.value : '');

        // Helper function to deal with hover effects.
        function applyHoverEffects(d, highlight = true) {
            if (!d) return;
            
            cells.style("fill", cell => {
                if (cell.isSum) return sumColorScale(cell.value);
                return (cell.x === d.x || cell.y === d.y)
                    ? highlightColorScale(cell.value + 3)
                    : cellColorScale(cell.value);
            });

            xLabels.classed("labelHighlight", (_, i) => i === d.x);
            yLabels.classed("labelHighlight", (_, i) => i === d.y);
        }

        // Add hover effects to cells and text
        [cells, texts].forEach(selection => {
            selection
            .on("mouseover", (event, d) => applyHoverEffects(d, true))
            .on("mouseout", () => applyHoverEffects(null, false));
        });

        // Adjust text size to fit within cells
        function adjustTextSize() {
            texts.each(function() {
                const text = d3.select(this);
                const maxSize = cellSize * 0.8;
                const currentSize = parseFloat(text.style("font-size"));
                const textWidth = this.getBBox().width;
                
                if (textWidth > maxSize) {
                    const newSize = (maxSize / textWidth) * currentSize;
                    text.style("font-size", `${newSize}px`);
                }
            });
        }
        adjustTextSize();
    }

    function visualizeTagFrequencyH(data) {
        const tags = Object.entries(prepTagData(data)).map(([tag, count]) => ({ tag, count }));
        tags.sort((a, b) => d3.descending(a.count, b.count));

        const width = 800;
        const height = 400;
        const barPadding = 5;

        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        const xScale = d3.scaleBand()
            .domain(tags.map(d => d.tag))
            .range([0, width])
            .padding(0.1);

        const yScale = d3.scaleLinear()
            .domain([0, d3.max(tags, d => d.count)])
            .range([height, 0]);

        // Create bars for tag frequency
        const barGroup = svg.selectAll(".barGroup")
            .data(tags)
            .enter().append("g")
            .attr("class", "barGroup"); 

        barGroup.append("rect")
            .attr("class", "bar")
            .attr("fill", "steelblue")
            .attr("x", d => xScale(d.tag))
            .attr("y", d => yScale(d.count))
            .attr("width", xScale.bandwidth())
            .attr("height", d => height - yScale(d.count))
            .on("click", function(event, d) {
                d3.selectAll(".bar").classed("selected", false);
                d3.select(this).classed("selected", true);
                updateList(d.tag, data);
            });

        // Append text labels
        barGroup.append("text")
            .attr("class", "label")
            .attr("x", d => xScale(d.tag) + (xScale.bandwidth()))
            .attr("y", d => yScale(d.count))
            .style("writing-mode", "sideways-lr")
            .attr('dy', '-0.5em')
            .attr('text-anchor', 'end')
            .style('font-size', '10px')            
            .text(d => d.tag);
    
        // Initial population of unfiltered list
        updateList(null, data);
    }

    function visualizeTagFrequency(data) {
        const tags = Object.entries(prepTagData(data)).map(([tag, count]) => ({ tag, count }));
        tags.sort((a, b) => d3.descending(a.count, b.count));

        const barHeight = 13;
        const marginTop = 30;
        const marginRight = 50;
        const marginBottom = 10;
        const marginLeft = 0;
        const width = 928;
        const height = Math.ceil((tags.length + 0.1) * barHeight) + marginTop + marginBottom;        

        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        const xScale = d3.scaleLinear()
            .domain([0, d3.max(tags, d => d.count)])
            .range([marginLeft, width - marginRight]);

        const yScale = d3.scaleBand()
            .domain(tags.map(d => d.tag))
            .range([marginTop, height - marginBottom])
            .padding(0.1);;
        

        // Create bars for tag frequency
        const barGroup = svg.selectAll(".barGroup")
            .data(tags)
            .enter().append("g")
            .attr("class", "barGroup")
            .attr("viewBox", [0, 0, width, height])
            .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;");

        barGroup.append("rect")
            .attr("class", "bar")
            .attr("fill", "steelblue")
            .attr("x", d => xScale(0))
            .attr("y", d => yScale(d.tag))
            .attr("width", d => (xScale(d.count) - xScale(0)))
            .attr("height", yScale.bandwidth())
            .on("click", function(event, d) {
                d3.selectAll(".bar").classed("selected", false);
                d3.select(this).classed("selected", true);
                updateList(d.tag, data);
            });

        // Append text labels
        barGroup.append("text")
            .attr("class", "label")
            .attr("x", d => xScale(d.count))
            .attr("y", d => yScale(d.tag)+ yScale.bandwidth() /2 )
            .attr("dy", "0.35em")
            .attr("dx", 13)
            .attr('text-anchor', 'start')
            .style('font-size', '10px')            
            .text(d => d.tag);
    
        // svg.append("g")
        //     .attr("transform", `translate(${marginLeft}, 0)`)
        //     .call(d3.axisLeft(yScale).tickSizeOuter(0));

        // Initial population of unfiltered list
        updateList(null, data);
    }

    // Update the list of items based on selected tag
    function updateList(selectedTag, data) {
        let itemList = [];
        itemList = data;
        const filteredItems = selectedTag ? itemList.filter(item => 
            item.tags && item.tags.includes(selectedTag)
        ) : itemList;
        const listElement = d3.select("#list");
        listElement.html("");
        filteredItems.forEach(item => {
            listElement.append("li").text(item.title || "No Title");
        });
    }

    function createTagCloud(data) {
        const tags = Object.entries(prepTagData(data))
            .map(([text, size]) => ({ text, size }));
        
        const width = 800, height = 400;
        
        const layout = d3.layout.cloud()
            .size([width, height])
            .words(tags)
            .padding(5)
            .rotate(() => 0)
            .fontSize(d => Math.sqrt(d.size) * 10)
            .on("end", draw);

        function draw(words) {
            const svg = d3.select("#cloud")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width/2},${height/2})`)
                .attr("class", "word-cloud");

            svg.selectAll("text")
                .data(words)
                .enter()
                .append("text")
                .style("font-size", d => `${d.size}px`)
                .style("fill", () => d3.interpolateRainbow(Math.random()))
                .attr("text-anchor", "middle")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .text(d => d.text)
                .on("click", function(event, d) {
                    updateList(d.text);
                });
        }

        layout.start();
    }

    async function loadJsonFile(filePath) {
    try {
        const response = await fetch(filePath);
        if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error loading JSON file:', error);
        throw error;
    }
    }

    // Update the initialization to create both visualizations
loadJsonFile('pocket-data.json')
        .then(data => {
            visualizeTagFrequency(data);
            createTagCloud(data);
            const preprocessedData = preprocessData(data);
            const cooccurrenceData = analyzeTagCooccurrence(preprocessedData);
            const cooccurrenceMatrix = generateCooccurrenceMatrix(cooccurrenceData);
            visualizeCooccurrenceMatrix(cooccurrenceMatrix);            
        })
   .catch(error => console.error(error));

    </script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>
</body>
</html>
